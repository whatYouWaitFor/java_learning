客户端与服务器数据交换格式xml、json、html（json轻量，占宽带小，xml重量）
通常互联网项目采用http+json（restful风格）；银行项目http+xml（webservice）
json有2种结构 对象{key:value} 数组["java","c++","vb"]
---------json与java对象互相转换复习

解析xml   用dom4j和sax（适合解析大文件）

java反射机制
核心，要获取当前类的class文件（
3种方式1.Class.forName("com.haha.User") 2.User.class 3.new User.getClass()）
Class class1 = User.class; class1.newInstance();//调用user类的无参构造方法

如何禁用java的反射机制-----将构造方法设置为private（但是也有api可以设置允许使用，springioc就是）

springIOC原理：使用dom4j+java反射
步骤1.读取xml文件  2.解析xml，遍历bean，获得类的全路径 3反射获得类，初始化类，赋值

网络通讯
http底层使用tcp协议进行连接
Socket技术：二进制+IP+端口号
upd面向无连接 tcp三次握手成功，才开始数据传输 ServerSocket

//转换成string类型
byte[] buf = new byte[1024];
int len = intputStrean.read(buf);
String str = new String(buf, 0, len);//这个是固定写法

NIO 数据从通道(channel)读取到缓冲区(buffer)，从缓冲区写到通道
缓冲Buffer    负责存储
ByteBuffer是最常用的 put()存入数据到缓冲区  get()获取缓冲区数据 flip()开启读模式
4个核心属性	position：缓冲区正在操作的位置 limit：缓冲区可以操作的数据大小 
capacity缓冲区最大容量，声明后不能改变

通道Channel    负责传输

同步阻塞和同步非阻塞（阻塞只有在网络条件才出现，本地不会出现）
最传统的IO也叫BIO，属于同步阻塞---服务器开启后，等待客户端发请求，就会一直阻塞
用多线程概念（伪同步阻塞）--->多线程占用太多内存---->用线程池
NIO，同步非阻塞

Netty  开发大多用netty4
长连接(移动端消息推送，MQ)，短连接(http协议)

TCP协议
粘包（如果基本上是同一时间发送，多个数据合成一个数据包）
拆包
防止粘包方法  1.消息定长 2.用特殊分隔符来区分比如：,

序列化  将对象序列化成二级制形式（字节数组），用于网络传输和持久化
反序列化  将二级制还原成对象

SpringBoot 面试问的基本是很基本的东西，没什么东西问，一些api，常用的注解
@EnableAutoConfiguration  让springboot进行spring框架的配置
@ComponentScan
@ControllerAdvice	@ExceptionHandler

项目使用到多数据源
利用分包（包名不同来区分）

事务
springboot集成事务，在方法上加上@Transactional即可

分布式事务
使用springboot+jta+atomikos来处理（适用于传统项目）
---先建2个数据源，创建2个类读取数据源属性，创建2个类来管理，atomikos来管理

springboot主流还是用yml比较多，用properties比较少了

微服务架构与面向服务架构区别：
面向服务架构（SOA）银行，企业级 xml格式传输 ESB服务 需要序列化和反序列化 重量级
微服务架构 更加细分，http+json+restful 轻量级 

SpringCloud-----一套微服务解决方案，RPC远程调用
调用服务原理：其他服务先注册到注册中心，然后通过httpClient底层技术来调用

ribbon负载均衡  原理  方案

接口网关 原理

分布式配置中心 原理

面试题
雪崩效应  微服务如何解决--hystrix 原理 熔断模式-再服务降级，隔离模式，限流模式
springboot和springcloud区别：1springboot简化xml配置，自带tomcat容器，集成web组件springmvc
springcloud 微服务框架，依赖springboot，用springmvc框架作为rpc接口调用

Dubbo---分布式服务框架（远程服务调用的分布式框架）

dubbo-admin 服务治理

JVM
jvm面试题1 内存机构---最重要4个：方法区，堆，栈，本地方法栈
jvm参数调优：1.减少垃圾回收机制次数 2.减少单次垃圾回收机制时间
a.堆内存初始值与最大值保持一致，减少次数  b.设置新生代与老年代比例，1/3或者1/4比较好

垃圾回收机制--不定时，清理堆内存不可达对象
finalize() 在垃圾回收机制前调用的

内存溢出：程序需要4g内存，但是系统只能给3g，满足不了需求，就产生内存溢出
内存泄露：定义了很多静态变量或者new了对象，没被使用，但是还在被引用，gc无法回收
防止内存泄露--1.像hashmap，arraylist等集合对象，被声明为static 
				2.成员变量初始化时要置空 3.监听器不再使用要取消注册

垃圾回收机制算法
1.引用计数法--垃圾回收时，如果对象被使用+1，不使用-1，为0时回收，默认15次
2.标记清除法--先标记可达或不可达，再逐个删除不可达对象（这个不好，产生碎片）
3.标记压缩法--在标记清除法基础上优化，把不可达压缩到一起再删（连续性，没碎片）
4.复制算法--S0和S1区轮流清空，每次清除一个区的不可达对象，把可达对象复制到另一个区
5.分代算法--分为新生代和老年代			
--标记清除和标记压缩都是在老年代；复制算法在新生代				

垃圾回收时会有停顿现象，因为所有线程会终止，防止又产生新的垃圾

垃圾回收器 	串行回收期，并行回收期

jvm调优总结：
1.堆内存初始值和最大值越大，吞吐量越大（而且初始值最好和最大值一样）
2.最好使用并行回收器，比串行吞吐量大，速度快
3.新生代和老年代比例最好是1：2或者1：3
4.减少GC对老年代的回收

MySql优化

